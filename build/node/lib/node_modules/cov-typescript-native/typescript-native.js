"use strict";
// Copyright (c) 2020 Synopsys, Inc. All rights reserved worldwide.
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const typescript_types_1 = require("./typescript-types");
const typescript_util_1 = require("./typescript-util");
function main() {
    let args = ts.sys.args;
    let reportDiagnostic = ts.createDiagnosticReporter(ts.sys);
    const commandLine = typescript_util_1.parseCommandLine(args, reportDiagnostic);
    let configFileParsingDiagnostics = undefined;
    const host = ts.createCompilerHost(commandLine.options, 
    /*setParentNodes*/ false);
    let projectReferences = undefined;
    let covOpts = commandLine.covOptions;
    let rootNames = commandLine.fileNames;
    let options = commandLine.options;
    // CMPJS-628: Since allowNOnTsExtension option is internal, it must be
    // set as option as any. This option bypasses extension limitation
    options.allowNonTsExtensions = true;
    const programOptions = {
        rootNames,
        options,
        projectReferences,
        host,
        configFileParsingDiagnostics
    };
    // Build a program using the set of root file names in fileNames
    let program = ts.createProgram(programOptions);
    if (covOpts.printNativeAST) {
        // Only prints the root files (those passed on the command line,
        // not resolved modules).
        typescript_util_1.printNativeAST(program);
    }
    let emitInfo = {
        generatedToSource: [],
        sourceToGenerated: []
    };
    function collectEmitInfo(fileName, data, writeByteOrderMark, onError, sourceFiles) {
        // Create a mapping of source files to generated files, and vice-versa.
        // Do not include source map files.
        if (!fileName.endsWith(".map")) {
            if (sourceFiles) {
                emitInfo.generatedToSource[fileName] = sourceFiles.map((sourceFile) => sourceFile.fileName);
                for (let sourceFile of sourceFiles) {
                    if (emitInfo.sourceToGenerated[sourceFile.fileName]
                        === undefined) {
                        emitInfo.sourceToGenerated[sourceFile.fileName] = [];
                    }
                    emitInfo.sourceToGenerated[sourceFile.fileName].push(fileName);
                }
            }
            else {
                emitInfo.generatedToSource[fileName] = [];
            }
        }
        // Emit the file.
        typescript_util_1.writeFile(fileName, data, covOpts.systemEncoding);
    }
    const exitStatus = typescript_util_1.emitFilesAndReportErrorsAndGetExitStatus(program, reportDiagnostic, covOpts, s => console.log(s), 
    /*reportSummary*/ undefined, collectEmitInfo);
    let programInfo = typescript_types_1.collectProgramInfo(program, covOpts);
    for (let sourceFile of programInfo.files) {
        sourceFile.generated = emitInfo.sourceToGenerated[sourceFile.path];
    }
    if (covOpts.collectTypes) {
        // Print some source-file-specific information to individual files, and
        // remove that information from the general output. This rearranging is
        // done as a performance enhancement, because it was found (CMPJS-679)
        // that reading/parsing the types.json file was a big time sink.
        for (let sourceFile of programInfo.files) {
            let expressionsNode = sourceFile.expressions;
            let moduleLinksNode = sourceFile.moduleLinks;
            let typeImportsNode = sourceFile.typeImports;
            let fileInfo = {
                expressions: expressionsNode,
                moduleLinks: moduleLinksNode,
                typeImports: typeImportsNode
            };
            let fileInfoStr = JSON.stringify(fileInfo, 
            /*replacer*/ undefined, 
            /*space*/ typescript_util_1.getDebug() ? 4 : 0);
            if (sourceFile.generated) {
                for (let genPath of sourceFile.generated) {
                    sourceFile.fileInfoPath = genPath + ".types.json";
                    typescript_util_1.writeFile(sourceFile.fileInfoPath, fileInfoStr, covOpts.systemEncoding);
                }
            }
            delete sourceFile.expressions;
            delete sourceFile.moduleLinks;
            delete sourceFile.typeImports;
        }
        // Print out the type information.
        let typeOutputName = "types.json";
        let typeInfostr = JSON.stringify(programInfo, 
        /*replacer*/ undefined, 
        /*space*/ typescript_util_1.getDebug() ? 4 : 0);
        // Write to file in outDir
        const typeOutputPath = ts.resolvePath(options.outDir, typeOutputName);
        typescript_util_1.writeFile(typeOutputPath, typeInfostr, covOpts.systemEncoding);
    }
    if (covOpts.summarizeFiles) {
        // Add the emit info and filter out type info, and produce a "files" file.
        delete programInfo.types;
        let fileInfostr = JSON.stringify(programInfo, 
        /*replacer*/ undefined, 
        /*space*/ typescript_util_1.getDebug() ? 4 : 0);
        // Write to file in outDir
        let fileOutputName = "files.json";
        const fileOutputPath = ts.resolvePath(options.outDir, fileOutputName);
        typescript_util_1.writeFile(fileOutputPath, fileInfostr, covOpts.systemEncoding);
    }
    return exitStatus;
}
process.exit(main());
