"use strict";
// Copyright (c) 2021 Synopsys, Inc. All rights reserved worldwide.
Object.defineProperty(exports, "__esModule", { value: true });
exports.collectProgramInfo = void 0;
const ts = require("typescript");
const typescript_util_1 = require("./typescript-util");
var ImportKind;
(function (ImportKind) {
    ImportKind[ImportKind["ES6_DEFAULT"] = 0] = "ES6_DEFAULT";
    ImportKind[ImportKind["ES6_NAMESPACE"] = 1] = "ES6_NAMESPACE";
    ImportKind[ImportKind["ES6_NAMED"] = 2] = "ES6_NAMED";
    ImportKind[ImportKind["COMMONJS_NAMESPACE"] = 3] = "COMMONJS_NAMESPACE";
})(ImportKind || (ImportKind = {}));
;
// No entry for ES11 dynamic import, because the TypeScript compiler does not
// resolve those.
var ModuleLinkFramework;
(function (ModuleLinkFramework) {
    ModuleLinkFramework["ES6"] = "MLF_ES6";
    ModuleLinkFramework["COMMONJS"] = "MLF_JS_COMMON";
})(ModuleLinkFramework || (ModuleLinkFramework = {}));
;
;
// Collect type objects, type declarations, and symbol types in a compilation unit.
function collectProgramInfo(program, covOptions) {
    let typeCount = program.getTypeCount();
    // Get the checker, we will use it to find more about classes
    let checker = program.getTypeChecker();
    let files = [];
    let nodes = [];
    let importedNames = new Map();
    let moduleLinks = [];
    let typeImports = [];
    let types = [];
    let currentNamespace = [];
    // Visit every sourceFile in the program and give each an id.
    // Store in this map to allow lookup for location info as we go along.
    let fileMap = new Map();
    let fileId = 0;
    for (let sourceFile of program.getSourceFiles()) {
        fileMap.set(sourceFile, fileId++);
    }
    let fileInfo;
    for (let [sourceFile, fileId] of fileMap.entries()) {
        let builtin = program.isSourceFileDefaultLibrary(sourceFile);
        fileInfo = {
            id: fileId,
            path: sourceFile.fileName,
            builtin: builtin,
            moduleLinks: moduleLinks,
            typeImports: typeImports,
            expressions: nodes,
            bom: sourceFile.bom
        };
        if (covOptions.disableEmitBuiltins && builtin) {
            // By default, emit types defined in all included libraries, but skip
            // them if --disable-emit-builtins is set.
        }
        else {
            try {
                if (covOptions.detectFlow) {
                    const scanner = ts.createScanner(sourceFile.languageVersion, 
                    /*skipTrivia*/ false, sourceFile.languageVariant, sourceFile.text, 
                    /*onError:*/ undefined, 0);
                    let tokenKind = scanner.scan();
                    while (ts.isTrivia(tokenKind)) {
                        if (tokenKind == ts.SyntaxKind.SingleLineCommentTrivia
                            || tokenKind == ts.SyntaxKind.MultiLineCommentTrivia) {
                            if (scanner.getTokenText().includes("@flow")) {
                                fileInfo.isFlow = true;
                                break;
                            }
                        }
                        tokenKind = scanner.scan();
                    }
                }
                if (covOptions.collectTypes || covOptions.detectJSX) {
                    // Identify imported symbols so we can add this information
                    // to types as necessary. This scan does not recurse beyond
                    // the top-level statements because imports must be at the
                    // global scope.
                    ts.forEachChild(sourceFile, scanImports);
                    // Walk the tree to collect type information.
                    ts.forEachChild(sourceFile, visit);
                    if (covOptions.detectJSX) {
                        if (fileInfo.isJSX === undefined) {
                            // We know that the file is not JSX now.
                            fileInfo.isJSX = false;
                        }
                    }
                }
            }
            catch (e) {
                typescript_util_1.printError("Unable to process source file", fileInfo.path + ":", e.message);
                console.error(e.stack);
            }
        }
        const syntacticDiagnostics = program.getSyntacticDiagnostics(sourceFile);
        if (syntacticDiagnostics !== undefined && syntacticDiagnostics.length !== 0) {
            fileInfo.hasSyntaxError = true;
        }
        files.push(fileInfo);
        // Refresh the file-specific collections.
        nodes = [];
        moduleLinks = [];
        typeImports = [];
        importedNames = new Map();
    }
    return {
        "files": files,
        "types": types,
    };
    function scanImports(node) {
        // Collect imported symbols to associate import info with types.
        if (ts.isImportDeclaration(node) && node.importClause) {
            let specifier = node.moduleSpecifier;
            // Only handle the case where the module specifier is a string.
            if (ts.isStringLiteral(specifier)) {
                let resolvedModuleLocation = program.getResolvedModuleWithFailedLookupLocationsFromCache(specifier.text, fileInfo.path);
                let compilerOptions = program.getCompilerOptions();
                let moduleKind = ts.getEmitModuleKind(compilerOptions);
                let moduleLink = {
                    id: moduleLinks.length,
                    linkString: specifier.text,
                    framework: moduleKind === ts.ModuleKind.ES2015
                        ? ModuleLinkFramework.ES6
                        : ModuleLinkFramework.COMMONJS,
                    resolvedPath: (resolvedModuleLocation && resolvedModuleLocation.resolvedModule)
                        ? resolvedModuleLocation.resolvedModule.resolvedFileName
                        : undefined
                };
                // Duplicate module links could exist, but should be rare.
                // Duplicates won't affect correctness, just efficiency.
                moduleLinks.push(moduleLink);
                let importClause = node.importClause;
                let importName = importClause.name;
                if (importName) {
                    // Default export.
                    let importSym = checker.getSymbolAtLocation(importName);
                    if (importSym) {
                        importedNames.set(importSym, {
                            moduleSpec: moduleLink.id,
                            importKind: ImportKind.ES6_DEFAULT,
                            importName: identifierToString(importName)
                        });
                    }
                }
                let bindings = importClause.namedBindings;
                if (bindings) {
                    if (ts.isNamedImports(bindings)) {
                        for (let importSpec of bindings.elements) {
                            let importName = importSpec.name;
                            let importSym = checker.getSymbolAtLocation(importName);
                            let exportName = importSpec.propertyName
                                ? importSpec.propertyName
                                : importName;
                            if (importSym) {
                                importedNames.set(importSym, {
                                    moduleSpec: moduleLink.id,
                                    importKind: ImportKind.ES6_NAMED,
                                    exportName: identifierToString(exportName),
                                    importName: identifierToString(importName)
                                });
                            }
                        }
                    }
                    else {
                        // NamespaceImport case
                        let importName = bindings.name;
                        let importSym = checker.getSymbolAtLocation(importName);
                        if (importSym) {
                            importedNames.set(importSym, {
                                moduleSpec: moduleLink.id,
                                importKind: ImportKind.ES6_NAMESPACE,
                                importName: identifierToString(importName)
                            });
                        }
                    }
                }
            }
        }
        else if (ts.isImportEqualsDeclaration(node)
            && ts.isExternalModuleReference(node.moduleReference)) {
            let specifier = node.moduleReference.expression;
            // Only handle the case where the module specifier is a string.
            if (ts.isStringLiteral(specifier)) {
                let resolvedModuleLocation = program.getResolvedModuleWithFailedLookupLocationsFromCache(specifier.text, fileInfo.path);
                let moduleLink = {
                    id: moduleLinks.length,
                    linkString: specifier.text,
                    framework: ModuleLinkFramework.COMMONJS,
                    resolvedPath: (resolvedModuleLocation && resolvedModuleLocation.resolvedModule)
                        ? resolvedModuleLocation.resolvedModule.resolvedFileName
                        : undefined
                };
                // Duplicate module links could exist, but should be rare.
                // Duplicates won't affect correctness, just efficiency.
                moduleLinks.push(moduleLink);
                let importName = node.name;
                let importSym = checker.getSymbolAtLocation(importName);
                if (importSym) {
                    importedNames.set(importSym, {
                        moduleSpec: moduleLink.id,
                        importKind: ImportKind.COMMONJS_NAMESPACE,
                        importName: identifierToString(importName)
                    });
                }
            }
        }
    }
    // Adjust to some location matching quirks by outputting duplicate
    // nodes with a different extent.
    function appendAdditionalNodes(node, nodeInfo, 
    /*append*/ nodes) {
        // Output another node matching the faulty location that
        // SpiderMonkey generates.
        if (ts.isFunctionLike(node) && node.name) {
            let nameNode = node.name;
            let nameRegion = getRegionOfNode(nameNode);
            if (nodeInfo.loc.begin.col !== nameRegion.begin.col
                || nodeInfo.loc.begin.line !== nameRegion.begin.line) {
                let startAtNameRegion = {
                    begin: nameRegion.begin,
                    end: nodeInfo.loc.end
                };
                // Clone the original NodeInfo and set the adjusted loc.
                let startAtNameNodeInfo = Object.assign({}, nodeInfo);
                startAtNameNodeInfo.loc = startAtNameRegion;
                nodes.push(startAtNameNodeInfo);
            }
            let parentNode = node.parent;
            while (ts.isAsExpression(parentNode)) {
                let asRegion = getRegionOfNode(parentNode);
                let nameToAsRegion = {
                    begin: nameRegion.begin,
                    end: asRegion.end
                };
                // Clone the original NodeInfo and set the adjusted loc.
                let nameToAsNodeInfo = Object.assign({}, nodeInfo);
                nameToAsNodeInfo.loc = nameToAsRegion;
                nodes.push(nameToAsNodeInfo);
                parentNode = parentNode.parent;
            }
        }
        else if (ts.isParameter(node) && (node.type || node.questionToken)) {
            // Output another node that excludes a parameter modifier or ...
            // token, which is where the sourcemap maps the parameter node.
            let doNewNode = false;
            let newStart = nodeInfo.loc.begin;
            if ((node.modifiers && node.modifiers.length > 0)
                || (node.decorators && node.decorators.length > 0)
                || node.dotDotDotToken) {
                doNewNode = true;
                let nameRegion = getRegionOfNode(node.name);
                newStart = nameRegion.begin;
            }
            let newEnd = nodeInfo.loc.end;
            if (node.initializer && node.type) {
                doNewNode = true;
                let typeRegion = getRegionOfNode(node.type);
                newEnd = typeRegion.end;
            }
            if (doNewNode) {
                // Clone the original NodeInfo and set the adjusted loc.
                let nameToTypeNodeInfo = Object.assign({}, nodeInfo);
                nameToTypeNodeInfo.loc = {
                    begin: newStart,
                    end: newEnd
                };
                nodes.push(nameToTypeNodeInfo);
            }
        }
        else {
            let endLocs = [nodeInfo.loc.end];
            // CMPJS-693: For function declarations within a case, output a node
            // with an end point for each cast. A closing parens may also be
            // included in the mapped location.
            if (ts.isFunctionLike(node) || ts.isClassLike(node)) {
                // In case of a nameless default export class declaration,
                // output a node for the "name" which has an empty extent at the
                // end of the "default" keyword. This allows the name-based
                // location matching fallback for this very specific case.
                if (ts.isClassDeclaration(node) && !node.name && node.modifiers) {
                    for (let mod of node.modifiers) {
                        if (mod.kind === ts.SyntaxKind.DefaultKeyword) {
                            let nameNodeInfo = serializeNode(mod);
                            nameNodeInfo.loc.begin = nameNodeInfo.loc.end;
                            nameNodeInfo.definedClassType = nodeInfo.type;
                            nodes.push(nameNodeInfo);
                            break;
                        }
                    }
                }
                let parentNode = node.parent;
                while (ts.isAsExpression(parentNode)
                    || ts.isParenthesizedExpression(parentNode)) {
                    let asRegion = getRegionOfNode(parentNode);
                    // Clone the original NodeInfo and set the adjusted loc.
                    let newNodeInfo = Object.assign({}, nodeInfo);
                    newNodeInfo.loc = {
                        begin: nodeInfo.loc.begin,
                        end: asRegion.end
                    };
                    nodes.push(newNodeInfo);
                    endLocs.push(asRegion.end);
                    parentNode = parentNode.parent;
                }
            }
            // Adjust the node start location to exclude any decorators
            // and/or modifiers, so that the location matches where the
            // sourcemap maps the node.
            // Decorators/modifiers are listed in "document order", and
            // will always precede the range we want to get. Decorators
            // must precede modifiers. Some modifiers (like "export")
            // are sometimes included in SpiderMonkey locations, so we
            // produce separate NodeInfos by removing each modifier one
            // by one from the left.
            let numDecorators = node.decorators ? node.decorators.length : 0;
            let numModifiers = node.modifiers ? node.modifiers.length : 0;
            let preludeElements = [];
            if (node.decorators && numDecorators > 0) {
                preludeElements.push(node.decorators[numDecorators - 1]);
            }
            if (node.modifiers) {
                preludeElements = preludeElements.concat(node.modifiers);
            }
            for (let preludeElement of preludeElements) {
                // Get the range from the end of the prelude element.
                let afterElementRange = {
                    pos: preludeElement.end,
                    end: node.end
                };
                // Strip leading whitespace.
                let file = getSourceFileOfNode(node);
                let noElementRegion = getRegionOfRange(file, afterElementRange);
                for (let endLoc of endLocs) {
                    // Clone the original NodeInfo and set the adjusted loc.
                    let newNodeInfo = Object.assign({}, nodeInfo);
                    newNodeInfo.loc = {
                        begin: noElementRegion.begin,
                        end: endLoc
                    };
                    nodes.push(newNodeInfo);
                }
                if (ts.isClassDeclaration(node)) {
                    // Class statements with an export modifier and
                    // extends clause are mapped to an empty range.
                    // Add an empty node to compensate.
                    let emptyAfterElementRange = {
                        pos: preludeElement.end,
                        end: preludeElement.end
                    };
                    let emptyAfterElementRegion = getRegionOfRange(file, emptyAfterElementRange, 
                    /*noStrip*/ true);
                    let emptyNodeInfo = Object.assign({}, nodeInfo);
                    emptyNodeInfo.loc = emptyAfterElementRegion;
                    nodes.push(emptyNodeInfo);
                }
            }
            let asteriskToken = getGeneratorAsteriskToken(node);
            if (asteriskToken) {
                // Get the range starting at the asterisk.
                let atAsteriskRange = {
                    pos: asteriskToken.pos,
                    end: node.end
                };
                // Convert to region.
                let file = getSourceFileOfNode(node);
                let atAsteriskRegion = getRegionOfRange(file, atAsteriskRange);
                for (let endLoc of endLocs) {
                    // Clone the original NodeInfo and set the adjusted loc.
                    let newNodeInfo = Object.assign({}, nodeInfo);
                    newNodeInfo.loc = {
                        begin: atAsteriskRegion.begin,
                        end: endLoc
                    };
                    nodes.push(newNodeInfo);
                }
            }
            if (ts.isClassDeclaration(node)) {
                // Class statements with an extends clause are mapped
                // to an empty range. Add an empty node to compensate.
                let emptyNodeInfo = Object.assign({}, nodeInfo);
                emptyNodeInfo.loc = {
                    begin: nodeInfo.loc.begin,
                    end: nodeInfo.loc.begin
                };
                nodes.push(emptyNodeInfo);
            }
        }
    }
    function isUninteresting(node) {
        // If in doubt, return false. Ignoring uninteresting nodes is an
        // optimization, but bad things happen if we ignore interesting ones.
        if (node.kind >= ts.SyntaxKind.FirstPunctuation
            && node.kind <= ts.SyntaxKind.LastPunctuation) {
            return true;
        }
        if (node.kind >= ts.SyntaxKind.FirstKeyword
            && node.kind <= ts.SyntaxKind.LastKeyword) {
            return true;
        }
        switch (node.kind) {
            case ts.SyntaxKind.EndOfFileToken:
            case ts.SyntaxKind.StringLiteral:
                return true;
            default:
                return false;
        }
    }
    function getGeneratorAsteriskToken(node) {
        if (node.asteriskToken) {
            if (!ts.isYieldExpression(node)) {
                return node.asteriskToken;
            }
        }
        return undefined;
    }
    /* Visit nodes finding exported classes */
    function visit(node) {
        // Ignore some leaf nodes, or nodes with no interesting children.
        if (isUninteresting(node)) {
            return;
        }
        if (covOptions.detectJSX) {
            if (fileInfo.isJSX) {
                if (!covOptions.collectTypes) {
                    // Cut off traversal of this file, since we know it's JSX.
                    return;
                }
            }
            // Detect if we encounter JSX syntax. This assumes that a file with
            // any JSX syntax will have a opening-like element (an opening or
            // self-closing element).
            else if (ts.isJsxOpeningLikeElement(node)) {
                fileInfo.isJSX = true;
            }
        }
        if (covOptions.collectTypes) {
            if (ts.isModuleDeclaration(node)) {
                // Module refers to an "internal module", which is old terminology
                // replaced by "namespace".
                // https://www.typescriptlang.org/docs/handbook/namespaces.html
                // Keep a stack of namespaces.
                // This calls visit to continue recursion.
                visitNamespace(node);
                return;
            }
            // Go ahead and visit the children for nodes that don't have a type
            // (that we care about).
            // If in doubt, just fall through, and we'll get some benign junk
            // in the expression-to-type mapping. This is an optimization.
            switch (node.kind) {
                case ts.SyntaxKind.Block:
                case ts.SyntaxKind.ImportDeclaration:
                case ts.SyntaxKind.NamedImports:
                case ts.SyntaxKind.VariableDeclarationList:
                case ts.SyntaxKind.VariableStatement:
                case ts.SyntaxKind.EmptyStatement:
                case ts.SyntaxKind.ExpressionStatement:
                case ts.SyntaxKind.IfStatement:
                case ts.SyntaxKind.DoStatement:
                case ts.SyntaxKind.WhileStatement:
                case ts.SyntaxKind.ForStatement:
                case ts.SyntaxKind.ForInStatement:
                case ts.SyntaxKind.ForOfStatement:
                case ts.SyntaxKind.ContinueStatement:
                case ts.SyntaxKind.BreakStatement:
                case ts.SyntaxKind.ReturnStatement:
                case ts.SyntaxKind.WithStatement:
                case ts.SyntaxKind.SwitchStatement:
                case ts.SyntaxKind.LabeledStatement:
                case ts.SyntaxKind.ThrowStatement:
                case ts.SyntaxKind.TryStatement:
                case ts.SyntaxKind.DebuggerStatement:
                    ts.forEachChild(node, visit);
                    return;
                default:
                // Fall through to retrieve and serialize the type.
            }
            // Collection location and Type info of all nodes with interesting type.
            let nodeInfo = serializeNode(node);
            // "Interesting" means not "any".
            if (!isAnyTypeId(nodeInfo.type)) {
                // The location of a node we serialize here is used to
                // associate the node's type information with the corresponding
                // AST node in cov-internal-js-fe...
                nodes.push(nodeInfo);
                // ...and therefore we hedge our bets in certain cases by
                // emitting additional nodes with the same type information,
                // but different locations. This practice has proven necessary
                // to compensate for some janky locations coming out of
                // SpiderMonkey, and for some quirks of the sourcemap produced
                // by TypeScript.
                appendAdditionalNodes(node, nodeInfo, nodes);
            }
            // Collect additional information on the Types that are declared by
            // these nodes.
            //
            // It would be better to retrieve all of this information while
            // processing the Type itself, but the TypeScript compiler API omits
            // (or at least hides) some data associated with some types that are
            // relevant to our API. The TypeScript compiler doesn't (in all cases)
            // support retrieving a declaration of a Type from the Type object,
            // so this is therefore a bit awkwardly structured.
            if (ts.isInterfaceDeclaration(node) || ts.isClassLike(node)) {
                // Interfaces and classes can be treated the same w.r.t. the type
                // they declare.
                updateTypeForInterfaceDeclaration(node, nodeInfo);
            }
            else if (ts.isEnumDeclaration(node)) {
                updateTypeForEnumDeclaration(node);
            }
            else if (ts.isTypeLiteralNode(node)) {
                updateTypeForTypeLiteral(node, nodeInfo);
            }
            else if (ts.isTypeNode(node)) {
                serializeTypeNode(node);
            }
        }
        ts.forEachChild(node, visit);
    }
    function visitNamespace(node) {
        let nsNameNode = node.name;
        let nsName;
        switch (nsNameNode.kind) {
            case ts.SyntaxKind.Identifier:
                nsName = identifierToString(nsNameNode);
                break;
            case ts.SyntaxKind.StringLiteral:
                nsName = nsNameNode.text;
                break;
            default:
                console.warn("Unable to determine namespace name");
                nsName = "";
                break;
        }
        enterNamespace(nsName);
        if (node.body) {
            visit(node.body);
        }
        exitNamespace();
    }
    function enterNamespace(nsName) {
        currentNamespace.push(nsName);
    }
    function prependNamespace(name) {
        let ret = name;
        let nsLen = currentNamespace.length;
        for (let i = nsLen - 1; i >= 0; --i) {
            ret = currentNamespace[i] + "." + ret;
        }
        return ret;
    }
    function exitNamespace() {
        return currentNamespace.pop();
    }
    function isAnyTypeId(id) {
        let anyId = getAnyTypeInfo().id;
        return id === anyId;
    }
    function getAnyType() {
        return checker.getAnyType();
    }
    function getObjectType() {
        // Initial creation of type node creates a "Synthesized" type.
        // This prevents typeNode from getting a proper type due to a
        // "checker" accessor check. Therefore, manually set typeNode.flag
        let typeNode = ts.createKeywordTypeNode(ts.SyntaxKind.ObjectKeyword);
        typeNode.flags = ts.NodeFlags.None; // Override the Synthesized flag
        let objType = checker.getTypeFromTypeNode(typeNode);
        objType.flags = ts.TypeFlags.NonPrimitive; // Initialize the type flag for debug print
        return objType;
    }
    function getObjectTypeInfo() {
        return serializeType(getObjectType());
    }
    function getAnyTypeInfo() {
        return serializeType(getAnyType());
    }
    function textRangeToString(file, rng) {
        return file.text.substring(rng.pos, rng.end);
    }
    function getStrippedRange(file, node) {
        // Nodes carry the start position of all the trivia (whitespace and
        // comments) that precede the actual text of the node. We need to adjust
        // this position to the actual start of the node.
        const scanner = ts.createScanner(file.languageVersion, 
        /*skipTrivia*/ true, file.languageVariant, file.text, 
        /*onError:*/ undefined, node.pos);
        let kind = scanner.scan();
        const start = scanner.getTokenPos();
        if (typescript_util_1.getDebug()) {
            // XXX Some cases yield end < start, which doesn't make sense but
            // does not seem to cause any tangible problems downstream.
            if (start > node.end) {
                typescript_util_1.printWarning("Invalid range", start + ":" + node.end);
            }
        }
        return { pos: start, end: node.end };
    }
    function getIdOfSourceFile(file) {
        // The || 0 reconsiles the type check, though it will not be undefined.
        return fileMap.get(file) || 0;
    }
    function getSourceFileOfNode(node) {
        return ts.getSourceFileOfNode(node);
    }
    function getRegionOfRange(file, range, noStrip) {
        let newRange;
        if (noStrip) {
            newRange = range;
        }
        else {
            // Strip off any preceding "trivia" to get a TextRange reflecting
            // the true start position, which is needed to match with the location
            // information in the sourcemap produced by transpilation.
            newRange = getStrippedRange(file, range);
        }
        let startPos = newRange.pos;
        let startInfo = ts.getLineAndCharacterOfPosition(file, startPos);
        let endInfo = ts.getLineAndCharacterOfPosition(file, range.end);
        let fileId = getIdOfSourceFile(file);
        return {
            begin: {
                file: fileId,
                line: startInfo.line + 1,
                col: startInfo.character + 1
            },
            end: {
                file: fileId,
                line: endInfo.line + 1,
                col: endInfo.character + 1
            }
        };
    }
    function getRegionOfNode(node) {
        let file = getSourceFileOfNode(node);
        return getRegionOfRange(file, node);
    }
    function serializeNode(node) {
        typescript_util_1.assert(node !== undefined, "Undefined node passed to serializeNode");
        let ret = {
            loc: getRegionOfNode(node),
            kind: node.kind
        };
        let nodeType;
        try {
            // This query can throw for expressions that do not correspond to
            // a symbol.
            nodeType = checker.getTypeAtLocation(node);
        }
        catch (e) {
            typescript_util_1.printDebug("[warning]: Unable to get type for expression:", JSON.stringify(ret));
            nodeType = getAnyType();
        }
        if (typescript_util_1.isTypeReference(nodeType)) {
            // XXX CMPJS-563: We currently do not have full support for
            // generic types, but this allows us to use the target type
            // (the uninstantiated type that has type parameters) for an
            // expression, rather than the "any" type.
            nodeType = nodeType.target;
        }
        let nodeTypeInfo;
        if (nodeType === undefined) {
            // This happens when the given type is an undefined identifier.
            typescript_util_1.printDebug("[warning]: Type for expression is undefined:", JSON.stringify(ret));
            nodeTypeInfo = getAnyTypeInfo();
        }
        else {
            nodeTypeInfo = serializeType(nodeType);
        }
        if (ts.isClassLike(node.parent)) {
            if (node === node.parent.name) {
                // The type checker claims that the class identifier node's
                // type is the class itself. That is not correct: it's type is
                // the builtin Function type.
                if (ts.isIdentifier(node)) {
                    let nameSym = checker.getSymbolAtLocation(node);
                    if (nameSym) {
                        // Note the class that the identifier represents.
                        ret.definedClassType = nodeTypeInfo.id;
                        nodeTypeInfo = serializeType(getTypeOfSymbolAtLocation(nameSym, node));
                    }
                }
            }
        }
        if (ts.isFunctionLike(node)) {
            let sigDeclNode = ret;
            sigDeclNode.signature = serializeSignatureDeclaration(node);
        }
        // Create object literal expression entries
        if (ts.isObjectLiteralExpression(node)) {
            nodeTypeInfo = getObjectTypeInfo();
        }
        ret.type = nodeTypeInfo.id;
        if (typescript_util_1.getDebug()) {
            let file = getSourceFileOfNode(node);
            let range = getStrippedRange(file, node);
            let text = textRangeToString(file, range);
            ret.debugKindName = typescript_util_1.syntaxKindToString(node.kind);
            ret.debugText = text;
        }
        ;
        return ret;
    }
    function identifierToString(id) {
        return ts.unescapeLeadingUnderscores(id.escapedText);
    }
    function serializePropertyName(name) {
        let nodeInfo = serializeNode(name);
        switch (name.kind) {
            case ts.SyntaxKind.PrivateIdentifier:
                nodeInfo.name = name.text;
                break;
            case ts.SyntaxKind.Identifier:
                nodeInfo.name = identifierToString(name);
                break;
            case ts.SyntaxKind.StringLiteral:
                nodeInfo.name = name.text;
                break;
            case ts.SyntaxKind.NumericLiteral:
                nodeInfo.name = Number(name.text);
                break;
            case ts.SyntaxKind.ComputedPropertyName:
                nodeInfo.name = undefined;
                break;
        }
        return nodeInfo;
    }
    function updateTypeForEnumDeclaration(decl) {
        let id = decl.name;
        let members = decl.members;
        let memberInfos = [];
        for (let member of members) {
            memberInfos.push({
                name: serializePropertyName(member.name),
                initializer: member.initializer
                    ? serializeNode(member.initializer)
                    : undefined
            });
        }
        let declType = checker.getTypeAtLocation(decl);
        let typeInfo = serializeType(declType);
        let nodeInfo = serializeNode(decl);
        nodeInfo.name = identifierToString(id);
        nodeInfo.enumerators = memberInfos;
        typeInfo.declaration = nodeInfo;
        return nodeInfo;
    }
    function getTypeOfSymbolAtLocation(sym, decl) {
        let symType = checker.getTypeOfSymbolAtLocation(sym, decl);
        if (typescript_util_1.isTypeReference(symType)) {
            // XXX CMPJS-563: We currently do not have full support for
            // generic types, but this allows us to use the target type
            // (the uninstantiated type that has type parameters) for an
            // expression, rather than the "any" type.
            symType = symType.target;
        }
        return symType;
    }
    function getTypeOfSymbol(sym) {
        for (let decl of (sym.declarations || [])) {
            let symType = getTypeOfSymbolAtLocation(sym, decl);
            return serializeType(symType);
        }
        return getAnyTypeInfo();
    }
    function serializeSignature(sig) {
        let retType = sig
            ? checker.getReturnTypeOfSignature(sig)
            : getAnyType();
        // XXX CMPJS-563: Strip reference to be consistent with serializeNode.
        if (typescript_util_1.isTypeReference(retType)) {
            retType = retType.target;
        }
        let retTypeInfo = serializeType(retType);
        let paramSyms = sig ? sig.parameters : [];
        let paramTypes = [];
        for (let paramSym of paramSyms) {
            let paramTypeInfo = getTypeOfSymbol(paramSym);
            paramTypes.push(paramTypeInfo.id);
        }
        let sigInfo = {
            parameterTypes: paramTypes,
            returnType: retTypeInfo.id,
        };
        if (typescript_util_1.getDebug()) {
            sigInfo.debugStr = sig
                ? typescript_util_1.signatureToString(sig, checker)
                : "undefined";
        }
        return sigInfo;
    }
    function serializeSignatureDeclaration(decl) {
        let sig = checker.getSignatureFromDeclaration(decl);
        let sigInfo = serializeSignature(sig);
        return sigInfo;
    }
    function getTypeId(ti) {
        return ti.id;
    }
    function serializeTypeNode(node) {
        let type = checker.getTypeFromTypeNode(node);
        let ret = serializeType(type);
        if (ts.isTypeReferenceNode(node)) {
            // Collect import provenance info for the type. This information is
            // specific to this file, so do not add it to the TypeInfo object.
            let typeNameNode = node.typeName;
            let accessPath = [];
            while (ts.isQualifiedName(typeNameNode)) {
                accessPath.unshift(identifierToString(typeNameNode.right));
                typeNameNode = typeNameNode.left;
            }
            let importSymbol = checker.getSymbolAtLocation(typeNameNode);
            if (importSymbol) {
                let importInfo = importedNames.get(importSymbol);
                if (importInfo) {
                    // Normalize the access path across ES6 import kinds.
                    if (importInfo.importKind === ImportKind.ES6_NAMED) {
                        typescript_util_1.assert(importInfo.exportName !== undefined, "Missing exported name for ES6 named import");
                        accessPath.unshift(importInfo.exportName);
                    }
                    else if (importInfo.importKind === ImportKind.ES6_DEFAULT) {
                        accessPath.unshift("default");
                    }
                    let t = checker.getTypeFromTypeNode(node);
                    let typeId = serializeType(t).id;
                    let typeImport;
                    let retrievedTypeImport = typeImports[typeId];
                    if (retrievedTypeImport) {
                        typeImport = retrievedTypeImport;
                    }
                    else {
                        typeImport = {
                            type: typeId,
                            importSpecs: []
                        };
                        typeImports[typeId] = typeImport;
                    }
                    // Avoid adding the same import info twice.
                    let seen = false;
                    let importSpecs = typeImport.importSpecs;
                    for (let priorSpec of typeImport.importSpecs) {
                        // Strict equality on the ModuleLink id.
                        if (priorSpec.moduleSpec !== importInfo.moduleSpec) {
                            continue;
                        }
                        let priorPath = priorSpec.accessPath;
                        // Different length access paths means a different spec.
                        if (accessPath.length !== priorPath.length) {
                            continue;
                        }
                        // Compare individual elements.
                        let diff = false;
                        for (let i = 0; i < accessPath.length; ++i) {
                            if (accessPath[i] !== priorPath[i]) {
                                diff = true;
                                break;
                            }
                        }
                        if (!diff) {
                            seen = true;
                            break;
                        }
                    }
                    if (!seen) {
                        let importSpec = {
                            moduleSpec: importInfo.moduleSpec,
                            accessPath: accessPath,
                            importName: importInfo.importName
                        };
                        typeImport.importSpecs.push(importSpec);
                    }
                }
            }
        }
        else if (ts.isIntersectionTypeNode(node) || ts.isUnionTypeNode(node)) {
            // Use the first declaration we encounter. This saves effort, and
            // also avoid overwriting the declaration of <type> in the case
            // where this union is <type> | null (which is technically the same
            // type when --strictNullChecks is not in effect).
            if (!ret.declaration) {
                let types = node.types.map(serializeTypeNode);
                ret.types = types.map(getTypeId);
                let declInfo = serializeNode(node);
                ret.declaration = declInfo;
            }
        }
        else if (ts.isFunctionTypeNode(node)) {
            ret.type = serializeTypeNode(node.type).id;
            if (typescript_util_1.getDebug()) {
                ret.debugStr = typescript_util_1.typeNodeToString(node, checker);
            }
        }
        else if (ts.isArrayTypeNode(node)) {
            ret.type = serializeTypeNode(node.elementType).id;
        }
        else if (ts.isTupleTypeNode(node)) {
            ret.elementTypes = serializeTypeNodeArray(node.elements).map(getTypeId);
        }
        else if (ts.isTemplateLiteralTypeNode(node)) {
            if (!ret.declaration) {
                if (type.isUnion()) {
                    let types = type.types.map(serializeType);
                    // Just represent this as a union of strings literal types as
                    // that is effectively what this is.
                    ret.types = types.map(getTypeId);
                    let declInfo = serializeNode(node);
                    ret.declaration = declInfo;
                }
            }
        }
        return ret;
    }
    function serializeTypeNodeArray(nodes) {
        let ret = [];
        for (let node of nodes) {
            ret.push(serializeTypeNode(node));
        }
        return ret;
    }
    function serializeName(nameNode) {
        if (ts.isIdentifier(nameNode)) {
            return identifierToString(nameNode);
        }
        else if (ts.isQualifiedName(nameNode)) {
            return serializeName(nameNode.left) + "."
                + identifierToString(nameNode.right);
        }
    }
    function serializeObjectType(t, info) {
        info.objectFlags = t.objectFlags;
        if (typescript_util_1.getDebug()) {
            info.debugObjectFlagNames = typescript_util_1.objectFlagsToString(t.objectFlags);
        }
        let constrSigs = checker.getSignaturesOfType(t, ts.SignatureKind.Construct);
        let constrInfos = constrSigs.map(serializeSignature);
        let callSigs = checker.getSignaturesOfType(t, ts.SignatureKind.Call);
        let sigInfos = callSigs.map(serializeSignature);
        info.constructors = constrInfos;
        info.signatures = sigInfos;
    }
    function serializeType(t) {
        let id = t.id;
        if (types[id] !== undefined) {
            return types[id];
        }
        let ret = {
            id: id,
            flags: t.flags
        };
        if (typescript_util_1.getDebug()) {
            ret.debugFlagNames = typescript_util_1.typeFlagsToString(t.flags);
        }
        // Log type here since object types can be recursive.
        types[id] = ret;
        // Object type handles most classes and interfaces
        if (typescript_util_1.isObjectType(t)) {
            serializeObjectType(t, ret);
        }
        return ret;
    }
    function serializeClassElement(elt) {
        let info;
        if (ts.isMethodDeclaration(elt)
            || ts.isAccessor(elt)
            || ts.isConstructorDeclaration(elt)) {
            let meth = serializeNode(elt);
            meth.hasBody = elt.body !== undefined;
            meth.signature = serializeSignatureDeclaration(elt);
            info = meth;
            info.name = elt.name
                ? serializePropertyName(elt.name)
                : undefined;
        }
        else {
            info = serializeNode(elt);
            info.name = elt.name
                ? serializePropertyName(elt.name)
                : undefined;
        }
        info.type = serializeType(checker.getTypeAtLocation(elt)).id;
        info.optional = false;
        // Adjust the node start location to exclude any decorators and/or
        // modifiers, so that the location matches where the sourcemap maps
        // the method node.
        let numDecorators = elt.decorators ? elt.decorators.length : 0;
        let numModifiers = elt.modifiers ? elt.modifiers.length : 0;
        // Decorators/modifiers are listed in "document order", and will
        // always precede the range we want to get. Decorators must precede
        // modifiers. We still need to strip leading whitespace, which
        // getRegionOfRange does for us.
        let lastPreludeElement;
        if (ts.isAccessor(elt)) {
            // The "get"/"set" is the last element to strip for accessors.
            let children = elt.getChildren();
            for (let child of children) {
                if (child.kind === ts.SyntaxKind.GetKeyword
                    || child.kind === ts.SyntaxKind.SetKeyword) {
                    lastPreludeElement = child;
                    break;
                }
            }
            // In the case of a non-abstract accessor with no body, the compiler
            // generates an error, but does not consider it a syntax error
            // for some reason, and generates code with an empty body.
            // The end location maps to the end of the parameter list, but
            // the current location ends with the method name.
            if (!info.hasBody) {
                let isConcrete = true;
                if (elt.modifiers) {
                    for (let mod of elt.modifiers) {
                        if (mod.kind === ts.SyntaxKind.AbstractKeyword) {
                            isConcrete = false;
                            break;
                        }
                    }
                }
                if (isConcrete) {
                    let lastChild = children[children.length - 1];
                    let file = getSourceFileOfNode(elt);
                    let endRegion = getRegionOfRange(file, lastChild);
                    info.loc.end = endRegion.end;
                    info.hasBody = true;
                }
            }
        }
        else if (ts.isMethodDeclaration(elt) && elt.asteriskToken) {
            lastPreludeElement = elt.asteriskToken;
        }
        else if (elt.modifiers && numModifiers > 0) {
            lastPreludeElement = elt.modifiers[numModifiers - 1];
        }
        else if (elt.decorators && numDecorators > 0) {
            lastPreludeElement = elt.decorators[numDecorators - 1];
        }
        if (lastPreludeElement) {
            let afterPreludeRange = {
                pos: lastPreludeElement.end,
                end: elt.end
            };
            let file = getSourceFileOfNode(elt);
            let noPreludeRegion = getRegionOfRange(file, afterPreludeRange);
            info.loc.begin = noPreludeRegion.begin;
        }
        return info;
    }
    function serializeTypeElement(elt) {
        let info;
        if (ts.isMethodSignature(elt) ||
            ts.isConstructSignatureDeclaration(elt) ||
            ts.isGetAccessorDeclaration(elt) ||
            ts.isSetAccessorDeclaration(elt)) {
            let meth = serializeNode(elt);
            meth.hasBody = false;
            meth.signature = serializeSignatureDeclaration(elt);
            info = meth;
        }
        else {
            info = serializeNode(elt);
        }
        info.name = elt.name
            ? serializePropertyName(elt.name)
            : undefined;
        info.type = serializeType(checker.getTypeAtLocation(elt)).id;
        info.optional = elt.questionToken !== undefined;
        return info;
    }
    function serializeHeritageClause(clause) {
        return {
            token: clause.token,
            types: clause.types.map(serializeTypeNode).map(getTypeId)
        };
    }
    function updateTypeForTypeLiteral(decl, nodeInfo) {
        let declType = checker.getTypeAtLocation(decl);
        let typeInfo = serializeType(declType);
        let memberInfos = decl.members.map(serializeTypeElement);
        typeInfo.members = memberInfos;
        typeInfo.declaration = nodeInfo;
    }
    function updateTypeForInterfaceDeclaration(decl, nodeInfo) {
        let declInfo = nodeInfo;
        let declId = decl.name;
        if (declId !== undefined) {
            let declName = identifierToString(declId);
            let nameWithNamespace = prependNamespace(declName);
            declInfo.name = nameWithNamespace;
        }
        // Get the type that we'll update.
        let declType = checker.getTypeAtLocation(decl);
        let typeInfo = serializeType(declType);
        typescript_util_1.assert(nodeInfo.type === typeInfo.id, "Interface type inconsistency:", nodeInfo.type, "!==", typeInfo.id);
        // For some reason, anonymous classes do not yet get the "Class" flag.
        if (ts.isClassLike(decl)) {
            typeInfo.objectFlags |= ts.ObjectFlags.Class;
        }
        // Use the declaration's property information since the Type object
        // seems to be disassociated with any constructor signature.
        let memberInfos;
        if (ts.isInterfaceDeclaration(decl)) {
            memberInfos = decl.members.map(serializeTypeElement);
        }
        else {
            memberInfos = decl.members.map(serializeClassElement);
        }
        // Multiple class/interface declarations can contribute members, so
        // check if members already exist and concatenate if so.
        typeInfo.members = typeInfo.members
            ? typeInfo.members.concat(memberInfos)
            : memberInfos;
        // objectFlags, signatures are already set up by serializeType.
        if (decl.heritageClauses) {
            typeInfo.bases = decl.heritageClauses.map(serializeHeritageClause);
        }
        typeInfo.declaration = nodeInfo;
    }
}
exports.collectProgramInfo = collectProgramInfo;
