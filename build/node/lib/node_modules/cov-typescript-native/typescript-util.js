"use strict";
// Copyright (c) 2021 Synopsys, Inc. All rights reserved worldwide.
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseCommandLine = exports.emitFilesAndReportErrorsAndGetExitStatus = exports.writeFile = exports.objectFlagsToString = exports.typeFlagsToString = exports.symbolFlagsToString = exports.syntaxKindToString = exports.signatureToString = exports.typeNodeToString = exports.typeToString = exports.isTypeReference = exports.isObjectType = exports.formatFlags = exports.printNativeAST = exports.assert = exports.printError = exports.printWarning = exports.printDebug = exports.getDebug = void 0;
const ts = require("typescript");
let fs = require('fs');
let path = require('path');
let iconv = require("iconv-lite");
// This module consists mostly of utility functions that we call instead of
// functions provided by the TypeScript compiler, so that we can modify certain
// behaviors.
/*
 * Output, error, and debugging utilities.
 */
let DEBUG = false;
function setDebug(val) {
    DEBUG = val;
}
function getDebug() {
    return DEBUG;
}
exports.getDebug = getDebug;
function printDebug(...msgs) {
    if (DEBUG) {
        console.error("[DEBUG]", ...msgs);
    }
}
exports.printDebug = printDebug;
function printWarning(...msgs) {
    console.error("[WARNING]", ...msgs);
}
exports.printWarning = printWarning;
function printError(...msgs) {
    console.error("[ERROR]", ...msgs);
}
exports.printError = printError;
function assert(cond, ...msgs) {
    if (!cond) {
        let msg = ["[ERROR]", ...msgs].join(" ");
        throw new Error(msg);
    }
}
exports.assert = assert;
function printSourceFileAST(sourceFile) {
    // Dump it.
    let astStr = JSON.stringify(sourceFile, /*replacer*/ undefined, /*space*/ 4);
    console.log(astStr);
}
function printNativeAST(program) {
    const fileNames = program.getRootFileNames();
    let idx = 0, lastIdx = fileNames.length - 1;
    console.log("[");
    fileNames.forEach((fileName) => {
        let sourceFile = program.getSourceFile(fileName);
        if (sourceFile) {
            printSourceFileAST(sourceFile);
        }
        else {
            printError("Unable to retrieve root file", fileName);
        }
        if (idx < lastIdx) {
            console.log(",");
        }
        ++idx;
    });
    console.log("]");
}
exports.printNativeAST = printNativeAST;
/*
 * Utilities to query the TypeScript API.
 */
exports.formatFlags = ts.TypeFormatFlags.NoTruncation |
    ts.TypeFormatFlags.UseFullyQualifiedType |
    ts.TypeFormatFlags.WriteArrowStyleSignature |
    ts.TypeFormatFlags.WriteClassExpressionAsTypeLiteral;
function isObjectType(t) {
    return t !== undefined && !!(t.flags & ts.TypeFlags.Object);
}
exports.isObjectType = isObjectType;
function isTypeReference(t) {
    if (isObjectType(t)) {
        return !!(t.objectFlags & ts.ObjectFlags.Reference);
    }
    return false;
}
exports.isTypeReference = isTypeReference;
function typeToString(t, checker) {
    return checker.typeToString(t, 
    /*enclosingDeclaration*/ undefined, exports.formatFlags);
}
exports.typeToString = typeToString;
function typeNodeToString(node, checker) {
    if (ts.isIntersectionTypeNode(node)
        || ts.isUnionTypeNode(node)) {
        let sep = ts.isUnionTypeNode(node) ? "|" : "&";
        let ret = "";
        let first = true;
        for (let conjunct of node.types) {
            if (first)
                first = false;
            else
                ret += " " + sep + " ";
            ret += typeNodeToString(conjunct, checker);
        }
        return ret;
    }
    let t = checker.getTypeFromTypeNode(node);
    return typeToString(t, checker);
}
exports.typeNodeToString = typeNodeToString;
function signatureToString(sig, checker) {
    return checker.signatureToString(sig, 
    /*enclosingDeclaration*/ sig.declaration, exports.formatFlags);
}
exports.signatureToString = signatureToString;
function syntaxKindToString(kind) {
    const syntaxKind = ts.SyntaxKind;
    return syntaxKind ? syntaxKind[kind] : kind.toString();
}
exports.syntaxKindToString = syntaxKindToString;
function symbolFlagsToString(flags) {
    return ts.Debug.formatSymbolFlags(flags);
}
exports.symbolFlagsToString = symbolFlagsToString;
function typeFlagsToString(flags) {
    return ts.Debug.formatTypeFlags(flags);
}
exports.typeFlagsToString = typeFlagsToString;
function objectFlagsToString(flags) {
    return ts.Debug.formatObjectFlags(flags);
}
exports.objectFlagsToString = objectFlagsToString;
/*
 * Filesystem-related utilities.
 */
function directoryExists(dirBuf) {
    try {
        const stat = fs.statSync(dirBuf);
        return stat.isDirectory();
    }
    catch (e) {
        return false;
    }
}
function makeDirectoryRecursive(dirName, encoding) {
    let dirBuf = iconv.encode(dirName, encoding);
    if (directoryExists(dirBuf)) {
        return;
    }
    let parentName = path.dirname(dirName);
    if (parentName !== "" && parentName !== dirName) {
        makeDirectoryRecursive(parentName, encoding);
    }
    fs.mkdirSync(dirBuf, { mode: "755" });
}
function writeFileEncoded(fileBuf, data) {
    let fd;
    try {
        fd = fs.openSync(fileBuf, "w");
        fs.writeSync(fd, data);
    }
    finally {
        if (fd !== undefined) {
            fs.closeSync(fd);
        }
    }
}
function writeFile(fileName, data, encoding) {
    if (process.platform === "win32") {
        // The ChakraHost implementation of System handles filename encoding.
        ts.sys.writeFile(fileName, data, /*writeByteOrderMark*/ false);
        return;
    }
    const dirName = path.dirname(fileName);
    let fileBuf;
    if (iconv.encodingExists(encoding)) {
        fileBuf = iconv.encode(fileName, encoding);
    }
    else {
        printWarning("Unsupported system encoding, outputting file path", fileName, "as UTF-8");
        fileBuf = Buffer.from(fileName, "utf8");
    }
    if (dirName) {
        makeDirectoryRecursive(dirName, encoding);
    }
    writeFileEncoded(fileBuf, data);
}
exports.writeFile = writeFile;
/*
 * Emit-related utilities.
 */
// Helper that emit files, report diagnostics and lists emitted and/or source
// files depending on compiler options.
//
// Adapted from the ts.emitFilesAndReportErrors @internal TypeScript API.
// Refactored to report a single syntax error for each file, or a filtered
// set of semantic errors for files withouth syntax error.
function emitFilesAndReportErrors(program, reportDiagnostic, covOptions, writeFileName, reportSummary, writeFile) {
    let options = program.getCompilerOptions();
    const isListFilesOnly = !!options.listFilesOnly;
    // First get config file parsing errors, option errors and global errors.
    const allDiagnostics = program.getConfigFileParsingDiagnostics().slice();
    const configFileParsingDiagnosticsLength = allDiagnostics.length;
    ts.addRange(allDiagnostics, program.getOptionsDiagnostics());
    if (!isListFilesOnly) {
        ts.addRange(allDiagnostics, program.getGlobalDiagnostics());
    }
    // Organize file-specific diagnostics by source file.
    let perFileErrors = new Map();
    // Filter the syntactic diagnostics so we only get the first for each
    // file. Otherwise we often get cascading failures that are not helpful.
    let filesWithSyntaxErrors = new Set();
    let syntacticDiagnostics = program.getSyntacticDiagnostics();
    for (let syntacticDiagnostic of syntacticDiagnostics) {
        if (!perFileErrors.has(syntacticDiagnostic.file)) {
            perFileErrors.set(syntacticDiagnostic.file, [syntacticDiagnostic]);
            filesWithSyntaxErrors.add(syntacticDiagnostic.file);
        }
    }
    // Emit and report any errors we ran into.
    const emitResult = isListFilesOnly
        ? { emitSkipped: true, diagnostics: [] }
        : program.emit(/*targetSourceFile*/ undefined, writeFile);
    const { emittedFiles, diagnostics: emitDiagnostics } = emitResult;
    ts.addRange(allDiagnostics, emitDiagnostics);
    // Collect semantic errors for a file if that file had no syntactic errors.
    let semanticDiagnostics = program.getSemanticDiagnostics();
    for (let semanticDiagnostic of semanticDiagnostics) {
        // Some semantic diagnostics are not useful to report, so filter them.
        // This error suggests using --allowSyntheticDefaultImports, which our
        // users cannot control and which does not affect the generated code.
        // It's also nonsensical in cases where the target module is unresolved.
        if (semanticDiagnostic.code == 2497)
            continue;
        if (!filesWithSyntaxErrors.has(semanticDiagnostic.file)) {
            let fileErrors = perFileErrors.get(semanticDiagnostic.file);
            if (fileErrors === undefined) {
                fileErrors = [];
                perFileErrors.set(semanticDiagnostic.file, fileErrors);
            }
            // Downgrade semantics errors to warnings.
            semanticDiagnostic.category = ts.DiagnosticCategory.Warning;
            fileErrors.push(semanticDiagnostic);
        }
    }
    for (let entry of perFileErrors.values()) {
        ts.addRange(allDiagnostics, entry);
    }
    const diagnostics = ts.sortAndDeduplicateDiagnostics(allDiagnostics);
    diagnostics.forEach(reportDiagnostic);
    if (writeFileName) {
        const currentDir = program.getCurrentDirectory();
        ts.forEach(emittedFiles, file => {
            const filepath = ts.getNormalizedAbsolutePath(file, currentDir);
            writeFileName(`TSFILE: ${filepath}`);
        });
        // Adapted from src/compiler/watch.ts:listFiles
        if (options.listFiles || isListFilesOnly) {
            ts.forEach(program.getSourceFiles(), file => {
                let builtin = program.isSourceFileDefaultLibrary(file);
                if (!covOptions.disableEmitBuiltins || !builtin) {
                    writeFileName(file.fileName);
                }
            });
        }
    }
    if (reportSummary) {
        reportSummary(ts.getErrorCountForSummary(diagnostics));
    }
    return {
        emitResult,
        diagnostics,
    };
}
// Adapted from the ts.emitFilesAndReportErrorsAndGetExitStatus @internal TypeScript API.
function emitFilesAndReportErrorsAndGetExitStatus(program, reportDiagnostic, covOptions, writeFileName, reportSummary, writeFile) {
    const { emitResult, diagnostics } = emitFilesAndReportErrors(program, reportDiagnostic, covOptions, writeFileName, reportSummary, writeFile);
    if (emitResult.emitSkipped && diagnostics.length > 0) {
        // If the emitter didn't emit anything, then pass that value along.
        return ts.ExitStatus.DiagnosticsPresent_OutputsSkipped;
    }
    else if (diagnostics.length > 0) {
        // The emitter emitted something, inform the caller if that happened in the presence
        // of diagnostics or not.
        return ts.ExitStatus.DiagnosticsPresent_OutputsGenerated;
    }
    return ts.ExitStatus.Success;
}
exports.emitFilesAndReportErrorsAndGetExitStatus = emitFilesAndReportErrorsAndGetExitStatus;
function parseCommandLine(args, reportDiagnostic) {
    let covOpts = {
        disableEmitBuiltins: false,
        collectTypes: false,
        detectJSX: false,
        detectFlow: false,
        printNativeAST: false,
        summarizeFiles: false,
        systemEncoding: "UTF-8",
    };
    let newArgs = [];
    let extraConfigFileName;
    for (let arg of args) {
        switch (arg) {
            case "--disable-emit-builtins":
                covOpts.disableEmitBuiltins = true;
                break;
            case "--log-debug":
                setDebug(true);
                break;
            case "--summarize-files":
                covOpts.summarizeFiles = true;
                break;
            case "--collect-types":
                covOpts.collectTypes = true;
                break;
            case "--detect-jsx":
                covOpts.detectJSX = true;
                break;
            case "--detect-flow":
                covOpts.detectFlow = true;
                break;
            case "--print-native-ast":
                covOpts.printNativeAST = true;
                break;
            default:
                if (arg.startsWith("--extra-config-json=")) {
                    extraConfigFileName = arg.substring(20);
                }
                else if (arg.startsWith("--system-encoding=")) {
                    covOpts.systemEncoding = arg.substring("--system-encoding=".length);
                }
                else {
                    newArgs.push(arg);
                }
        }
    }
    let commandLine = ts.parseCommandLine(newArgs);
    if (extraConfigFileName) {
        const { options } = ts.parseConfigFileWithSystem(extraConfigFileName, 
        /*optionsToExtend*/ {}, 
        /*extendedConfigCache*/ undefined, 
        /*watchOptionsToExtend*/ undefined, ts.sys, reportDiagnostic);
        if (options.rootDirs) {
            commandLine.options.rootDirs = options.rootDirs;
        }
        if (options.paths) {
            commandLine.options.paths = options.paths;
        }
    }
    commandLine.covOptions = covOpts;
    return commandLine;
}
exports.parseCommandLine = parseCommandLine;
